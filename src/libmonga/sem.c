#include "mon_sem.h"

#include <setjmp.h>
#include <string.h>
#include <stdarg.h>
#include <stdatomic.h>
#include <stdint.h>

#include "sem/symbol.h"
#include "sem/types.h"
#include "sem/scope.h"
#include "sem/builtins.h"

#include "mon_ast.h"
#include "mon_vector.h"
#include "mon_alloc.h"
#include "mon_debug.h"

// SETJMP error codes:
#define SETJMP_OK  0
#define SETJMP_ERR 1
//

/** Performs a longjmp to the context's jump buffer, passing SETJMP_ERR as 'val'. */
#define THROW(ctx) longjmp(((struct SemAnalysisCtx_*)ctx)->jmpBuf, SETJMP_ERR)

/**
 * 	Contains the state of a semantic analysis.
 */
struct SemAnalysisCtx_ {

    /** The ASTs to be analysed. */
    Mon_Ast* targetAsts;

    /** The number of ASTs to be analysed. */
    int targetAstCount;

    /** The AST being targeted for this semantic analysis. */
    Mon_Ast* currentAst;

    /** The scope at the top of the scope stack. */
    Scope* currentScope;

    /** The stream to output errors to. */
    FILE* errStream;

    /** Stores data used by longjmp that allows error handling. */
    jmp_buf jmpBuf;

    /** The total number of anonymous types created.  */
    int anonRecCount;

    int loopLevel;
};
typedef volatile struct SemAnalysisCtx_ SemAnalysisCtx;

// Foward declarations
static bool ResolveExpression(SemAnalysisCtx* ctx, Mon_AstExp* exp);
static bool ResolveBlock(SemAnalysisCtx* ctx, Mon_AstBlock* block, Mon_AstFuncDef* enclosingFunction);
static void LogError(const SemAnalysisCtx* ctx, const Mon_AstNodeHeader* errNodeHeader, const char* fmt, ...);
//

static void AddUsedType(SemAnalysisCtx* ctx, Mon_AstTypeDef* type) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(type);

    if (Mon_VectorContains(&ctx->currentAst->semantic.usedTypes, type)) {
        return;
    }

    if (Mon_VectorPush(&ctx->currentAst->semantic.usedTypes, type) != MON_SUCCESS) {
        THROW(ctx);
    }
}

/**
 * 	Pushes a scope onto the scope stack. longjmps if memory fails.
 */
static void PushScope(SemAnalysisCtx* ctx) {
    MON_CANT_BE_NULL(ctx);
    
    Scope* scope = Mon_Alloc(sizeof(Scope));
    if (scope == NULL) {
        THROW(ctx);
    }
    
    if (Mon_VectorInit(&scope->symbols) != MON_SUCCESS) {
        Mon_Free(scope);
        THROW(ctx);
    }

    scope->parentScope = ctx->currentScope;
    ctx->currentScope = scope;
}

/**
 * 	Pops the current scope from the stack and sets the current scope
 * 	to the one that was right below it. Releases garbage generated by
 * 	the scope (no need to call DestroyScope() after popping).
 */
static void PopScope(SemAnalysisCtx* ctx) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(ctx->currentScope);

    Scope* parent = ctx->currentScope->parentScope;
    DestroyScope(ctx->currentScope);
    ctx->currentScope = parent;
}

/**
 *  Registers the specified symbol in the current scope.
 *  Automatically validates if the symbol already exists in
 *  the current scope or is part of the builtin scope.
 * 
 *  If an allocation fails or the specified symbol is,
 *  this function will throw and destroy the symbol.
 * 
 *  If the symbol name was already defined in the current scope,
 *  an error is logged, false is returned and the symbol is destroyed.
 * 
 *  If the symbol name is the same as one of the builtin symbols,
 *  an error is logged, false is returned and the symbol is destroyed.
 * 
 *  If everything is succesful, returns true.
 */
static bool TryRegisterSymbol(SemAnalysisCtx* ctx, Mon_AstNodeHeader* symNodeHeader, Symbol* s) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(symNodeHeader);

    if (s == NULL) {
        THROW(ctx);
    }

    // Find clash in current scope.
    Mon_RetCode ret = TryAddSymbolToScope(ctx->currentScope, s);
    
    switch (ret)
    {
        case MON_SUCCESS:
            return true;

        case MON_ERR_DUPLICATE:
            LogError(ctx, symNodeHeader, "Redeclaration of %s '%s'.",
                    GetSymbolKindName(s->kind), s->symName);
            DestroySymbol(s);
            return false;

        case MON_ERR_BUILTIN:
            LogError(ctx, symNodeHeader, "Invalid symbol name '%s' - name is a reserved Monga identifier.",
                    s->symName);
            DestroySymbol(s);
            return false;

        case MON_ERR_NOMEM:
            DestroySymbol(s);
            THROW(ctx);
            return false;

        default:
            return false;
    }
}

/**
 * 	Releases any garbage contained within the specified context.
 */
static void Cleanup(SemAnalysisCtx* ctx) {
    MON_CANT_BE_NULL(ctx);

    // Destroy any remaining scopes
    Scope* curr = ctx->currentScope;
    while (curr != NULL) {
        Scope* parent = curr->parentScope;
        DestroyScope(curr);
        curr = parent;
    }
}

/**
 *  Logs an error to the context error output stream.
 *  errNodeHeader is a pointer to the header of a node that contains
 *  an error. Can be set to NULL if the error is not related to a specific
 *  node.
 */
static void LogError(const SemAnalysisCtx* ctx, const Mon_AstNodeHeader* errNodeHeader, const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);

    if (ctx->errStream != NULL) {
        fprintf(ctx->errStream, "[Error] Module %s, line %d, column %d: ",
            ctx->currentAst->moduleName, errNodeHeader->line, errNodeHeader->column);
        vfprintf(ctx->errStream, fmt, args);
        fprintf(ctx->errStream, "\n");
    }

    va_end(args);
}

/**
 * 	Searches for a type within the scope. If none is found,
 * 	NULL is returned. If rec is true, searches for ascendant scopes as
 *  well.
 */
static Mon_AstTypeDef* FindType(const Scope* scope, const char* name, bool rec) {
    MON_CANT_BE_NULL(scope);
    MON_CANT_BE_NULL(name);

    Symbol* sym = FindSymbolInScope(scope, name, rec);
    if (sym == NULL) {
        return NULL;
    }

    return (sym->kind == SYM_TYPE)
        ? sym->definition.type 
        : NULL;
}

/**
 *  Resolves the semantics of a variable reference, filling its 'semantic' fields.
 *  Returns true if the semantics were resolved succesfully, false otherwise.
 */
static bool ResolveVar(SemAnalysisCtx* ctx, Mon_AstVar* var) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(var);

    Scope* s = ctx->currentScope;    

    switch (var->varKind) {
        case MON_VAR_DIRECT: {
            Symbol* sym = FindSymbolInScope(s, var->var.direct.name, true);
            if (sym == NULL) {
                LogError(ctx, &var->header, "Variable '%s' was not declared in this scope.", 
                         var->var.direct.name);
                return false;
            }

            // Direct access variables may be accessing either a function parameter
            // or a declared variable. Treat each one accordingly.
            if (sym->kind == SYM_VAR) {
                var->var.direct.semantic.definition.varDef = sym->definition.var;
                var->var.direct.semantic.definitionKind = MON_SEM_VARDEF_VAR;
                var->semantic.type = var->var.direct.semantic.definition.varDef->semantic.type;
                return true;
            } else if (sym->kind == SYM_PARAM) {
                var->var.direct.semantic.definition.paramDef = sym->definition.param;
                var->var.direct.semantic.definitionKind = MON_SEM_VARDEF_PARAM;
                var->semantic.type = var->var.direct.semantic.definition.paramDef->semantic.type;
                return true;
            } else {
                LogError(ctx, &var->header, "'%s' is a '%s', but is being used as a variable name.", 
                         var->var.direct.name, GetSymbolKindName(sym->kind));
                
                return false;
            }
        }

        case MON_VAR_FIELD:
            if (!ResolveExpression(ctx, var->var.field.expr)) {
                return false;
            }

            // If we are accessing an error-type expression field,
            // simply bypass the error message.
            if (var->var.field.expr->semantic.type == BUILTIN_TABLE->types.tError) {
                return false;
            }

            // Expression must be structured to have a field accessed.
            if (!IsStructuredType(var->var.field.expr->semantic.type)) {
                LogError(ctx, &var->var.field.expr->header, "Tried to access field of an expression with non-structured type.");
                return false;
            }

            // Expression is resolved and of structured type. We must now find if
            // the type in the expression contains the user-requested field.
            Mon_AstField* field = GetTypeField(var->var.field.expr->semantic.type, var->var.field.fieldName);
            if (field == NULL) {
                // Here, we already know that the expression is structured because
                // we already checked for it previously.
                // The only possible error left is the non-existence of the
                // specified field.
                LogError(ctx, &var->header, "Specified field '%s' does not exist in value of type '%s'.", 
                    var->var.field.fieldName, 
                    var->var.field.expr->semantic.type->typeName);
                return false;
            }
            var->semantic.type = field->semantic.type;
            var->var.field.semantic.field = field;
            return true;

        case MON_VAR_INDEXED:
            if (!ResolveExpression(ctx, var->var.indexed.indexedExpr) ||
                !ResolveExpression(ctx, var->var.indexed.indexExpr)) {
                return false;
            }

            // Index expression must be integer type.
            if (!IsIntegerType(var->var.indexed.indexExpr->semantic.type)) {
                LogError(ctx, &var->var.indexed.indexExpr->header, 
                        "Expression of type '%s' cannot be used as index (use an integer type).",
                        var->var.indexed.indexExpr->semantic.type);
                return false;
            }

            // Indexed expression must be indexable.
            var->semantic.type = GetIndexedType(var->var.indexed.indexedExpr->semantic.type);
            if (var->semantic.type == NULL) {
                LogError(ctx, &var->var.indexed.indexedExpr->header, "Cannot index expression of type '%s'.", 
                         var->var.indexed.indexedExpr->semantic.type->typeName);
                return false;
            }
            return true;
    }

    return false;
}

/**
 *  Resolves the semantics of a function call, filling its 'semantic' fields.
 *  Returns true if the semantics were resolved succesfully, false otherwise.
 */
static bool ResolveCall(SemAnalysisCtx* ctx, Mon_AstCall* call) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(call);

    bool ret = true;

    // Find function definition
    Symbol* sym = FindSymbolInScope(ctx->currentScope, call->funcName, true);
    if (sym == NULL) {
        LogError(ctx, &call->header, "Function '%s' was not defined in this scope.", call->funcName);
        return false;
    }

    if (sym->kind != SYM_FUNC) {
        LogError(ctx, &call->header, "Cannot call '%s': a '%s' is not callable.",
            call->funcName,
            GetSymbolKindName(sym->kind));
        return false;
    }

    Mon_AstFuncDef* funcDef = sym->definition.func;
    int passedArgsCount = Mon_VectorCount(&call->parameterList);
    int expectedArgsCount = Mon_VectorCount(&funcDef->parameters);

    if (passedArgsCount < expectedArgsCount) {
        LogError(ctx, &call->header, "Too few arguments to call '%s'. (expected %d, got %d).",
            call->funcName,
            expectedArgsCount,
            passedArgsCount);
        return false;
    }
    if (passedArgsCount > expectedArgsCount) {
        LogError(ctx, &call->header, "Too many arguments to call '%s'. (expected %d, got %d).",
            call->funcName,
            expectedArgsCount,
            passedArgsCount);
        return false;
    }

    // The number of arguments is correct, now evaluate each of them
    // and pass them to the function.
    for (int i = 0; i < expectedArgsCount; ++i) {
        Mon_AstExp* paramExp = Mon_VectorGet(&call->parameterList, i);
        if (!ResolveExpression(ctx, paramExp)) {
            return false;
        }

        // No need to resolve parameter definition because it has already
        // been resolved when its function definition was being resolved.
        Mon_AstParam* paramDef = Mon_VectorGet(&funcDef->parameters, i);

        if (!IsTypeAssignableFrom(paramDef->semantic.type, paramExp->semantic.type)) {
            LogError(ctx, &paramExp->header, "Parameter type mismatch in '%s' function call. Passed argument %d, of type '%s', "
                          "cannot be assigned to a parameter of type '%s'.",
                          call->funcName, 
                          i + 1,
                          paramExp->semantic.type->typeName,
                          paramDef->semantic.type->typeName);
            return false;
        }
    }

    call->semantic.callee = funcDef;

    return ret;
}

/**
 *  Finds or creates an anonymous array type for an existing type and returns
 *  the created type node. If a new one is generated, it is added to the ctx AST
 *  with a name that is guaranteed not to cause collisions with user-defined types.
 *  If a memory allocation failure occurs, this function will call THROW().
 */
static Mon_AstTypeDef* FindOrCreateArrayType(SemAnalysisCtx* ctx, Mon_AstTypeDef* innerType) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(innerType);

    // Anonymous array types will be prefixed with the following prefix:
    static const char prefix[] = "@array_";

    // In practice, anonymous array types will be named as the example below:
    // new int[24] -> creates an anonymous type of name '@array_int'.

    size_t bufLen = sizeof(prefix) + strlen(innerType->typeName);
    char* buf = Mon_Alloc(bufLen); // No need to add space for '\0' because
                                   // it is already included in sizeof(prefix).

    if (buf == NULL) {
        THROW(ctx);
    }
    strcpy(buf, prefix);
    strcat(buf, innerType->typeName);

    Symbol* s = FindSymbolInScope(ctx->currentScope, buf, true);
    if (s != NULL) {
        // Anonymous type was already found, re-use it.
        MON_ASSERT(s->kind == SYM_TYPE, "symbol returned from resolved inner type name must be of 'type' kind.");
        Mon_Free(buf);
        return s->definition.type;
    }

    // Anonymous type symbol did not exist previously, we
    // need to create it now. Simply create artificial AST nodes
    // and perform tedious allocation failure checkups.
    Mon_AstTypeDesc* anonInnerTypeDesc = Mon_AstTypeDescNewAlias(innerType->typeName);
    if (anonInnerTypeDesc == NULL) {
        Mon_Free(buf);
        THROW(ctx);
    }
    anonInnerTypeDesc->typeDesc.alias.semantic.aliasedType = innerType;

    Mon_AstTypeDesc* anonTypeDesc = Mon_AstTypeDescNewArray(anonInnerTypeDesc);
    if (anonTypeDesc == NULL) {
        Mon_AstTypeDescDestroy(anonInnerTypeDesc, false);
        THROW(ctx);
    }

    Mon_AstTypeDef* anonTypeDef = Mon_AstTypeDefNew(buf, bufLen - 1, anonTypeDesc);
    if (anonTypeDef == NULL) {
        Mon_AstTypeDescDestroy(anonTypeDesc, true);
        Mon_Free(buf);
        THROW(ctx);
    }

    anonTypeDef->typeDesc->typeDesc.array.semantic.innerTypeDef = innerType;

    Symbol* anonSym = NewTypeSymbol(anonTypeDef);
    if (anonSym == NULL) {
        Mon_AstTypeDefDestroy(anonTypeDef, true);
        Mon_Free(buf);
        THROW(ctx);            
    }

    if (!ForceAddSymbolToScope(ctx->currentScope, anonSym)) {
        DestroySymbol(anonSym);
        Mon_AstTypeDefDestroy(anonTypeDef, true);
        Mon_Free(buf);
        THROW(ctx);
    }

    Mon_AstDef* def = Mon_AstDefNewType(anonTypeDef);
    if (def == NULL) {
        DestroySymbol(anonSym);
        Mon_AstTypeDefDestroy(anonTypeDef, true);
        Mon_Free(buf);
        THROW(ctx);        
    }

    // Add it to the AST. This is necessary because the ownership of all AST
    // nodes referenced by any nodes of this AST belongs to the AST itself.
    // Conveniently, we won't need to handle the deletion of created anonymous
    // nodes because they will be discarded altogether with other AST nodes when
    // the tree is destroyed.
    if (Mon_DefGroupReg(&ctx->currentAst->definitions, def) != MON_SUCCESS) {
        DestroySymbol(anonSym);
        Mon_Free(buf);
        Mon_AstDefDestroy(def, true);
        THROW(ctx);        
    }

    return anonTypeDef;    
}

static Mon_AstTypeDef* CreateAnonymousRecord(SemAnalysisCtx* ctx, Mon_AstTypeDesc* typeDesc) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(typeDesc);
    MON_ASSERT(typeDesc->typeDescKind == MON_TYPEDESC_RECORD,
        "Can only create anonymous record types for resolved anonymous record typedescs.");

    static const char format[] = "@record_%x";

    Mon_AstTypeDef* ret;

    // The extra (sizeof(int)*2) is the necessary amount of bytes
    // to fit any unsigned integer into the string, since every byte
    // in HEX representation will fit in two characters.
#define COUNT ((sizeof(format)/sizeof(char) + (sizeof(unsigned int) * 2)))
    char name[COUNT];
    sprintf(name, format, ctx->anonRecCount);
    name[COUNT - 1] = 0;
    
    // Create typedef
    ret = Mon_AstTypeDefNew(name, COUNT, typeDesc);
    if (ret == NULL) {
        THROW(ctx);
    }

#undef COUNT
    // Create symbol
    Symbol* sym = NewTypeSymbol(ret);
    if (sym == NULL) {
        Mon_AstTypeDefDestroy(ret, false);
        THROW(ctx);
    }

    // Add symbol to scope
    if (!ForceAddSymbolToScope(ctx->currentScope, sym)) {
        DestroySymbol(sym);
        Mon_AstTypeDefDestroy(ret, false);
        THROW(ctx);
    }

    Mon_AstDef* def = Mon_AstDefNewType(ret);
    if (def == NULL) {
        DestroySymbol(sym);
        Mon_AstTypeDefDestroy(ret, false);
        THROW(ctx);
    }

    // Add to AST
    if (Mon_DefGroupReg(&ctx->currentAst->definitions, def) != MON_SUCCESS) {
        DestroySymbol(sym);
        Mon_AstDefDestroy(def, true);
        THROW(ctx);
    }

    // All ok
    ctx->anonRecCount++;

    return ret;
}


static bool ResolveCondition(SemAnalysisCtx* ctx, Mon_AstCond* cond) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(cond);

    switch (cond->condKind) {
        case MON_COND_BIN:
            return ResolveCondition(ctx, cond->condition.binCond.left) &&
                   ResolveCondition(ctx, cond->condition.binCond.right);

        case MON_COND_COMPARISON:
            if (!ResolveExpression(ctx, cond->condition.compar.left) ||
                !ResolveExpression(ctx, cond->condition.compar.right)) {
                return false;
            }
            if (!TypeCanCompare(cond->condition.compar.left->semantic.type,
                                cond->condition.compar.right->semantic.type,
                                cond->condition.compar.comparKind)) {
                LogError(ctx, &cond->header, "Invalid comparison between values of types '%s' and '%s'.",
                         cond->condition.compar.left->semantic.type->typeName,
                         cond->condition.compar.right->semantic.type->typeName);
                return false;
            }
            return true;

        default:
            MON_ASSERT(false, "Unimplemented condition kind. (got %d)", (int)cond->condKind);
            return false;
    }
}

/**
 *  Resolves the semantics of an expression, filling its 'semantic' fields.
 *  Returns true if the semantics were resolved succesfully, false otherwise.
 */
static bool ResolveExpression(SemAnalysisCtx* ctx, Mon_AstExp* exp) {
    MON_CANT_BE_NULL(exp);
    MON_CANT_BE_NULL(ctx);

    if (exp->semantic.type != NULL) {
        return exp->semantic.type;
    }

    Scope* s = ctx->currentScope;
    Mon_AstTypeDef* type;

    exp->semantic.type = NULL;

    switch (exp->expKind) {		
        case MON_EXP_CONDITIONAL:
            if (!ResolveCondition(ctx, exp->exp.conditionalExpr.condition) ||
                !ResolveExpression(ctx, exp->exp.conditionalExpr.thenExpr) ||
                !ResolveExpression(ctx, exp->exp.conditionalExpr.elseExpr)) {
                return false;
            }
            type = GetCondExpResultType(exp->exp.conditionalExpr.thenExpr->semantic.type,
                                        exp->exp.conditionalExpr.elseExpr->semantic.type);

            if (type == NULL) {
                LogError(ctx, &exp->header,
                              "Ambiguous result type for conditional expression. The 'then' type (preceded by the ?) "
                              "must be assignable from a value of 'else' type (preceded by the ':').");
                return false;
            }

            exp->semantic.type = type;
            return true;
            
        case MON_EXP_UNOP:
            if (!ResolveExpression(ctx, exp->exp.unaryOperation.operand)) {
                return false;
            }
            type = GetUnopResultType(exp->exp.unaryOperation.operand->semantic.type, exp->exp.unaryOperation.unOpKind);
            if (type == NULL) {
                LogError(ctx, &exp->header, "Invalid unary operation for type '%s'.", 
                         exp->exp.unaryOperation.operand->semantic.type->typeName);
                return false;
            }

            exp->semantic.type = type;
            return true;

        case MON_EXP_BINOP:
            if (!ResolveExpression(ctx, exp->exp.binaryOperation.left) ||
                !ResolveExpression(ctx, exp->exp.binaryOperation.right)) {
                return false;
            }

            type = GetBinopResultType(exp->exp.binaryOperation.left->semantic.type, 
                                      exp->exp.binaryOperation.right->semantic.type, 
                                      exp->exp.binaryOperation.binOpKind);

            if (type == NULL) {
                LogError(ctx, &exp->header, "Invalid binary operation between types '%s' and '%s'.", 
                         exp->exp.binaryOperation.left->semantic.type->typeName,
                         exp->exp.binaryOperation.right->semantic.type->typeName);
                return false;
            }
            exp->semantic.type = type;
            return true;

        case MON_EXP_CAST:
            if (!ResolveExpression(ctx, exp->exp.castExpr.castee)) {
                return false;
            }
            type = FindType(s, exp->exp.castExpr.typeName, true);
            if (type == NULL) {
                LogError(ctx, &exp->header, "Failed cast: '%s' could not be resolved to a type.", 
                         exp->exp.castExpr.typeName);
                return false;
            } else if (!IsTypeCastableFrom(type, exp->exp.castExpr.castee->semantic.type)) {
                LogError(ctx, &exp->header, "Failed cast: cannot cast '%s' to '%s'.", 
                         exp->exp.castExpr.typeName,
                         exp->exp.castExpr.castee->semantic.type->typeName);
                return false;
            }
            exp->semantic.type = type;
            return true;

        case MON_EXP_VAR:
            if (!ResolveVar(ctx, exp->exp.varExpr)) {
                return false;
            }
            exp->semantic.type = exp->exp.varExpr->semantic.type;
            break;

        case MON_EXP_LITERAL:
            if (exp->exp.literalExpr.literalKind == MON_LIT_INT) {
                int64_t val = exp->exp.literalExpr.integer;
                if (val > INT32_MAX || val < INT32_MIN) {
                    type = BUILTIN_TABLE->types.tLong;
                } else {
                    type = BUILTIN_TABLE->types.tInt;
                }
                exp->semantic.type = type;
                return true;
            } else if (exp->exp.literalExpr.literalKind == MON_LIT_FLOAT) {
                type = BUILTIN_TABLE->types.tDouble;                
                exp->semantic.type = type;
                return true;
            } else if (exp->exp.literalExpr.literalKind == MON_LIT_STR) {
                type = BUILTIN_TABLE->types.tString;
                exp->semantic.type = type;
                return true;
            } else {
                MON_ASSERT(false, "Unimplemented literalKind. (got %d)", (int)exp->exp.literalExpr.literalKind);
            }
            break;

        case MON_EXP_CALL:
            if (!ResolveCall(ctx, exp->exp.callExpr)) {
                return false;
            }
            exp->semantic.type = exp->exp.callExpr->semantic.callee->semantic.returnType;
            return true;

        case MON_EXP_NULL:
            exp->semantic.type = FindType(BUILTIN_SCOPE, TYPENAME_NULL, false);
            MON_ASSERT(exp->semantic.type != NULL, TYPENAME_NULL " must be in builtin scope.");
            return true;

        case MON_EXP_NEW: {
            Mon_AstTypeDef* type = FindType(ctx->currentScope, exp->exp.newExpr.typeName, true);
            if (type == NULL) {
                LogError(ctx, &exp->header, "Cannot resolve '%s' into a type.", exp->exp.newExpr.typeName);
                return false;
            }
            if (exp->exp.newExpr.arraySizeExp != NULL) {
                // Array size expression not null, this is
                // an array instantiation (new type[exp])
                if (!ResolveExpression(ctx, exp->exp.newExpr.arraySizeExp)) {
                    return false;
                }
                if (!IsIntegerType(exp->exp.newExpr.arraySizeExp->semantic.type)) {
                    LogError(ctx, &exp->exp.newExpr.arraySizeExp->header, "Array size expression must have integer type.");
                    return false;
                }
                // Array expression and type are fine, create an anonymous type
                // for this array instantiation. No need to check return type
                // since FindOrCreateArrayType throws on allocation errors.
                exp->semantic.type = FindOrCreateArrayType(ctx, type); 
                return true;
            } else if (!IsRefType(type)) {
                // New expression does not refer to an array instantiation, it must
                // then only refer to an instatiation of a ref-type object.    
                LogError(ctx, &exp->header, "'new' can only be used to instantiate values of a record or array type.");
                return false;
            }
            // Since this is a simple object instantiation, the resulting
            // type is the user-specified type in instantiation.
            exp->semantic.type = type;
            return true;
        }

        default:
            MON_ASSERT(false, "Unimplemented expKind. (got %d).", (int)exp->expKind);
            break;
    }

    return exp->semantic.type != NULL;
}

static bool ResolveVarDefinition(SemAnalysisCtx* ctx, Mon_AstVarDef* varDef) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(varDef);

    bool ret = true;

    // Find if variable type exists
    Mon_AstTypeDef* type = FindType(ctx->currentScope, varDef->typeName, true);
    if (type == NULL) {
        LogError(ctx, &varDef->header, "Unknown type '%s' for variable '%s'.", varDef->typeName, varDef->varName);
        type = BUILTIN_TABLE->types.tError;
        ret = false;
    }

    varDef->semantic.type = type;

    // Variable type exists, now try to register its symbol.
    ret = TryRegisterSymbol(ctx, &varDef->header, NewVarSymbol(varDef)) && ret;

    if (ret) {
        AddUsedType(ctx, varDef->semantic.type);
        return true;
    }
    return false;
}

static bool ResolveStatement(SemAnalysisCtx* ctx, Mon_AstStatement* stmt, Mon_AstFuncDef* enclosingFunction) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(stmt);

    switch (stmt->statementKind) {
        case MON_STMT_VARDEF:
            return ResolveVarDefinition(ctx, stmt->statement.varDef);

        case MON_STMT_IF: {
            bool condResolved = ResolveCondition(ctx, stmt->statement.ifStmt.condition);
            PushScope(ctx);
            bool thenResolved = ResolveBlock(ctx, stmt->statement.ifStmt.thenBlock, enclosingFunction);
            PopScope(ctx);
            bool elseResolved = true;
            if (stmt->statement.ifStmt.elseBlock != NULL) {
                PushScope(ctx);
                elseResolved = ResolveBlock(ctx, stmt->statement.ifStmt.elseBlock, enclosingFunction);
                PopScope(ctx);
            }
            return condResolved && thenResolved && elseResolved;                    
        }

        case MON_STMT_WHILE: {
            ctx->loopLevel++;
            PushScope(ctx);
            bool ret = ResolveCondition(ctx, stmt->statement.whileStmt.condition) &&
                ResolveBlock(ctx, stmt->statement.whileStmt.block, enclosingFunction);
            PopScope(ctx);
            ctx->loopLevel--;
            return ret;
        }

        case MON_STMT_ASSIGNMENT:
            if (!ResolveExpression(ctx, stmt->statement.assignment.rvalue) ||
                !ResolveVar(ctx, stmt->statement.assignment.lvalue)) {
                return false;
            }
            
            Mon_AstTypeDef* lType = stmt->statement.assignment.lvalue->semantic.type;
            Mon_AstTypeDef* rType = stmt->statement.assignment.rvalue->semantic.type;

            if (!IsTypeAssignableFrom(lType, rType)) {
                LogError(ctx, &stmt->header, "Cannot assign value of type '%s' to lvalue of type '%s'.",
                    rType->typeName, lType->typeName);
                return false;
            }
            return true;

        case MON_STMT_RETURN:
            if (stmt->statement.returnStmt.returnedExpression == NULL) {
                // Empty return case
                if (enclosingFunction->semantic.returnType != FindType(BUILTIN_SCOPE, "void", false)) {
                    LogError(ctx, &stmt->header, "Function %s cannot have an empty return statement (must return value of type %s).",
                             enclosingFunction->funcName, enclosingFunction->semantic.returnType->typeName);
                    return false;
                }
                return true;
            }
            
            if (!ResolveExpression(ctx, stmt->statement.returnStmt.returnedExpression)) {
                return false;
            }            

            if (!IsTypeAssignableFrom(enclosingFunction->semantic.returnType, 
                                      stmt->statement.returnStmt.returnedExpression->semantic.type)) {
                LogError(ctx, &stmt->header, "Cannot return value of type '%s' in function declared with return type '%s'.",
                    stmt->statement.returnStmt.returnedExpression->semantic.type->typeName,
                    enclosingFunction->semantic.returnType->typeName);
                return false;
            }
            return true;

        case MON_STMT_BREAK:
        case MON_STMT_CONTINUE:
            if (ctx->loopLevel <= 0) {
                LogError(ctx, &stmt->header, "Statement can only be used within loops.");
                return false;
            }
            return true;

        case MON_STMT_CALL:
            return ResolveCall(ctx, stmt->statement.call);

        case MON_STMT_BLOCK: {
            PushScope(ctx);
            bool resolved = ResolveBlock(ctx, stmt->statement.block, enclosingFunction);
            PopScope(ctx);
            return resolved;
        }

        case MON_STMT_ECHO:
            return ResolveExpression(ctx, stmt->statement.echo.echoedExp);

        default:
            MON_ASSERT(false, "Unimplemented statement kind. (got %d)", (int)stmt->statementKind);
            return false;
    }
}

/**
 *  Resolves an execution block. Does not enter a new scope.
 */
static bool ResolveBlock(SemAnalysisCtx* ctx, Mon_AstBlock* block, Mon_AstFuncDef* enclosingFunction) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(block);
    MON_CANT_BE_NULL(enclosingFunction);

    bool ret = true;

    // Resolve all statements in the block
    MON_VECTOR_FOREACH(&block->statements, Mon_AstStatement*, stmt,
        ret = ResolveStatement(ctx, stmt, enclosingFunction) && ret;

        if (!block->semantic.allPathsReturn) {
            // For each statement, we need to check if they are returning values.
            switch (stmt->statementKind) {
                case MON_STMT_BLOCK:
                    block->semantic.allPathsReturn = stmt->statement.block->semantic.allPathsReturn;
                    break;

                case MON_STMT_IF:
                    if (stmt->statement.ifStmt.elseBlock == NULL) {
                        break;
                    }
                    block->semantic.allPathsReturn = stmt->statement.ifStmt.thenBlock->semantic.allPathsReturn && 
                                                     stmt->statement.ifStmt.elseBlock->semantic.allPathsReturn;
                    break;

                case MON_STMT_RETURN:
                    block->semantic.allPathsReturn = true;
                    break;

                case MON_STMT_WHILE:
                case MON_STMT_BREAK:
                case MON_STMT_CONTINUE:
                case MON_STMT_CALL:
                case MON_STMT_ECHO:
                case MON_STMT_VARDEF:
                case MON_STMT_ASSIGNMENT:
                    break;
            }
        }
    );

    return ret;
}

static bool ResolveFunctionDeclaration(SemAnalysisCtx* ctx, Mon_AstFuncDef* funcDef) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(funcDef);

    bool ret = true;

    // Try to register function in scope.
    if (!TryRegisterSymbol(ctx, &funcDef->header, NewFuncSymbol(funcDef))) {
        return false;
    }

    // Keep index of function symbol.
    int index = Mon_VectorCount(&ctx->currentScope->symbols) - 1;

    // Resolve function return type
    Mon_AstTypeDef* type = FindType(ctx->currentScope, funcDef->funcRetTypeName, true);
    if (type == NULL) {
        LogError(ctx, &funcDef->header, "Type not found: '%s'.", funcDef->funcRetTypeName);
        type = BUILTIN_TABLE->types.tError;
        ret = false;
    }

    // Return type validated.
    funcDef->semantic.returnType = type;

    PushScope(ctx);

    // Now, validate parameter definitions.
    int argCount = Mon_VectorCount(&funcDef->parameters);

    for (int i = 0; i < argCount; ++i) {
        Mon_AstParam* param = Mon_VectorGet(&funcDef->parameters, i);

        // Validate function parameter type
        type = FindType(ctx->currentScope, param->typeName, true);
        if (type == NULL) {
            LogError(ctx, &funcDef->header, "Cannot resolve '%s' (declared type of parameter '%s') into a type.",
                     param->typeName, param->name);
            type = BUILTIN_TABLE->types.tError;
            ret = false;
        }

        param->semantic.type = type;

        if (!TryRegisterSymbol(ctx, &param->header, NewParamSymbol(param))) {
            // Failed parameter resolution (name clash), remove function from the scope.
            PopScope(ctx);
            Mon_VectorRemove(&ctx->currentScope->symbols, index);
            return false;
        }
        AddUsedType(ctx, type);
    }

    PopScope(ctx);
    if (ret) {
        AddUsedType(ctx, funcDef->semantic.returnType);
    }
    return ret;
}

static bool ResolveFunctionImpl(SemAnalysisCtx* ctx, Mon_AstFuncDef* funcDef) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(funcDef);

    if (funcDef->body == NULL) {
        // No implementation to resolve.
        return true;
    }

    PushScope(ctx);

    MON_VECTOR_FOREACH(&funcDef->parameters, Mon_AstParam*, param,
        // Parameter name clashes have already been validated in function
        // declaration. It is still a good idea to check if this hasn't
        // happened properly in debug mode.
#ifdef MON_DEBUG
        bool ok = TryRegisterSymbol(ctx, &param->header, NewParamSymbol(param));
        MON_ASSERT(ok, "Cannot have parameter name clashes in resolution of function implementation.");
#else
        Symbol* s = NewParamSymbol(param);
        if (s == NULL) {
            THROW(ctx);
        }

        if (!ForceAddSymbolToScope(ctx->currentScope, s)) {
            DestroySymbol(s);
            THROW(ctx);
        }
#endif
    );

    bool blockResolved = ResolveBlock(ctx, funcDef->body, funcDef);

    PopScope(ctx);

    if (!blockResolved) {
        return false;
    }

    // Block has been resolved, now check for necessary returns.
    if (funcDef->semantic.returnType != BUILTIN_TABLE->types.tVoid &&
        !funcDef->body->semantic.allPathsReturn) {
        LogError(ctx, &funcDef->body->header, "Not all paths are returning a value.");
        return false;
    }

    return true;
}

static bool ResolveTypeDescription(SemAnalysisCtx* ctx, Mon_AstTypeDesc* typeDesc) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(typeDesc);

    Mon_AstTypeDef* typeDef = NULL;

    bool ret = true;

    switch (typeDesc->typeDescKind) {
        case MON_TYPEDESC_ALIAS:
            typeDef = FindType(ctx->currentScope, typeDesc->typeDesc.alias.aliasedTypeName, true);
            if (typeDef == NULL) {
                LogError(ctx, &typeDesc->header, "Could not resolve '%s' into a type.", 
                         typeDesc->typeDesc.alias.aliasedTypeName);
                typeDef = BUILTIN_TABLE->types.tError;
                ret = false;
            }
            typeDesc->typeDesc.alias.semantic.aliasedType = typeDef;
            AddUsedType(ctx, typeDef);
            return ret;

        case MON_TYPEDESC_RECORD: {
            int fieldCount = Mon_VectorCount(&typeDesc->typeDesc.record.fields);

            // Enter a new scope in order to properly create
            // the record fields.
            PushScope(ctx);

            for (int i = 0; i < fieldCount; ++i) {
                Mon_AstField* field = Mon_VectorGet(&typeDesc->typeDesc.record.fields, i);

                // Find field's type
                Mon_AstTypeDef* fieldType = FindType(ctx->currentScope, field->typeName, true);
                if (fieldType == NULL) {
                    LogError(ctx, &typeDesc->header, "Cannot resolve '%s' (in declaration of field '%s') into a type.",
                             field->typeName, field->fieldName);
                    PopScope(ctx);
                    fieldType = BUILTIN_TABLE->types.tError;
                    ret = false;
                }

                field->semantic.type = fieldType;

                // Type was well resolved, now try to add field the symbol into the
                // current scope.
                if (!TryRegisterSymbol(ctx, &field->header, NewFieldSymbol(field))) {
                    PopScope(ctx);
                    return false;
                }
                AddUsedType(ctx, field->semantic.type);
            }
            PopScope(ctx);
            return ret;
        }

        case MON_TYPEDESC_ARRAY:
            if (!ResolveTypeDescription(ctx, typeDesc->typeDesc.array.innerTypeDesc)) {
                return false;
            }

            if (typeDesc->typeDesc.array.innerTypeDesc->typeDescKind == MON_TYPEDESC_ARRAY) {
                typeDesc->typeDesc.array.semantic.innerTypeDef = FindOrCreateArrayType(ctx, typeDesc->typeDesc.array.innerTypeDesc->typeDesc.array.semantic.innerTypeDef);
                
            } else if (typeDesc->typeDesc.array.innerTypeDesc->typeDescKind == MON_TYPEDESC_ALIAS) {
                typeDesc->typeDesc.array.semantic.innerTypeDef = typeDesc->typeDesc.array.innerTypeDesc->typeDesc.alias.semantic.aliasedType;
                
            } else if (typeDesc->typeDesc.array.innerTypeDesc->typeDescKind == MON_TYPEDESC_RECORD) {
                typeDesc->typeDesc.array.semantic.innerTypeDef = CreateAnonymousRecord(ctx, typeDesc->typeDesc.array.innerTypeDesc);

            } else {
                MON_ASSERT(false, "Unimplemented type desc. (got %d)", (int)typeDesc->typeDesc.array.innerTypeDesc->typeDescKind);
            }
            AddUsedType(ctx, typeDesc->typeDesc.array.semantic.innerTypeDef);

            return true;

        case MON_TYPEDESC_PRIMITIVE:
            return true;

        default:
            MON_ASSERT(false, "Unimplemented typedesc kind. (got %d)", (int)typeDesc->typeDescKind);
            break;
    }

    return false;
}

static bool ResolveTypeDeclaration(SemAnalysisCtx* ctx, Mon_AstTypeDef* typeDef) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(typeDef);

    return TryRegisterSymbol(ctx, &typeDef->header, NewTypeSymbol(typeDef));
}

static bool ResolveTypeDefinition(SemAnalysisCtx* ctx, Mon_AstTypeDef* typeDef) {
    MON_CANT_BE_NULL(ctx);
    MON_CANT_BE_NULL(typeDef);

    return ResolveTypeDescription(ctx, typeDef->typeDesc);
}

static Mon_RetCode Analyse(SemAnalysisCtx* ctx) {
    MON_CANT_BE_NULL(ctx);

    // Set checkpoint for memory errors
    if (setjmp(((struct SemAnalysisCtx_*)ctx)->jmpBuf) != SETJMP_OK) {
        // Allocation errors occurred, cleanup and return accordingly.
        Cleanup(ctx);
        return MON_ERR_NOMEM;
    }
    // Make sure builtin scope is succesfully created:
    if (BUILTIN_SCOPE == NULL) {
        return MON_ERR_NOMEM;
    }

    // No errors occurred, proceed with normal execution.
    PushScope(ctx);

    bool ret = true;

    // Considering symbol dependencies, symbols must be analysed in the following
    // order:
    //  Type declarations
    //  Function declarations
    //  Global variable declarations
    //  Type descriptions
    //  Function implementations
    //
    
    // Analyse type declarations:
    for (int i = 0; i < ctx->targetAstCount; ++i) {
        ctx->currentAst = &ctx->targetAsts[i];
        ctx->currentAst->astState = MON_ASTSTATE_SEM_OK;

        Mon_VectorInit(&ctx->currentAst->semantic.usedTypes);

        MON_DEFGROUP_FOREACH(&ctx->currentAst->definitions, def,
            if (def->defKind != MON_AST_DEF_TYPE) {
                continue;
            }

            if (!ResolveTypeDeclaration(ctx, def->definition.type)) {
                ctx->currentAst->astState = MON_ASTSTATE_SEM_ERR;
                ret = false;
            }
        );
    }

    // Analyse function declarations:
    for (int i = 0; i < ctx->targetAstCount; ++i) {
        ctx->currentAst = &ctx->targetAsts[i];

        MON_DEFGROUP_FOREACH(&ctx->currentAst->definitions, def,
            if (def->defKind != MON_AST_DEF_FUNC) {
                continue;
            }

            if (!ResolveFunctionDeclaration(ctx, def->definition.function)) {
                ctx->currentAst->astState = MON_ASTSTATE_SEM_ERR;
                ret = false;
            }
        );
    }

    // Analyse global variables:
    for (int i = 0; i < ctx->targetAstCount; ++i) {
        ctx->currentAst = &ctx->targetAsts[i];

        MON_DEFGROUP_FOREACH(&ctx->currentAst->definitions, def,
            if (def->defKind != MON_AST_DEF_VAR) {
                continue;
            }

            if (!ResolveVarDefinition(ctx, def->definition.variable)) {
                ctx->currentAst->astState = MON_ASTSTATE_SEM_ERR;
                ret = false;
            }
        );
    }

    // Analyse type definitions:
    MON_VECTOR_FOREACH(&ctx->currentScope->symbols, Symbol*, s,
        if (s->kind != SYM_TYPE) {
            continue;
        }

        if (!ResolveTypeDefinition(ctx, s->definition.type)) {
            ctx->currentAst->astState = MON_ASTSTATE_SEM_ERR;
            ret = false;
        }
    );

    // Analyse function implementations:
    MON_VECTOR_FOREACH(&ctx->currentScope->symbols, Symbol*, s,
        if (s->kind != SYM_FUNC) {
            continue;
        }

        if (!ResolveFunctionImpl(ctx, s->definition.func)) {
            ctx->currentAst->astState = MON_ASTSTATE_SEM_ERR;
            ret = false;
        }
    );

    Cleanup(ctx);

    return ret ? MON_SUCCESS : MON_ERR_SEMANTIC;
}

Mon_RetCode Mon_SemAnalyse(Mon_Ast* ast, FILE* semErrOutStream) {
    MON_CANT_BE_NULL(ast);

    return Mon_SemAnalyseMultiple(ast, 1, semErrOutStream);
}

Mon_RetCode Mon_SemAnalyseMultiple(Mon_Ast* asts, int astCount, FILE* semErrOutStream) {
    MON_CANT_BE_NULL(asts);

    SemAnalysisCtx ctx;
    ctx.currentScope = NULL;
    ctx.currentAst = &asts[0];
    ctx.errStream = semErrOutStream;

    ctx.targetAstCount = astCount;
    ctx.targetAsts = asts;

    ctx.loopLevel = 0;
    ctx.anonRecCount = 0;

    return Analyse(&ctx);
}