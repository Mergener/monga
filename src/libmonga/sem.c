#include "sem.h"

#include <setjmp.h>
#include <string.h>

#include "sem/symbol.h"
#include "sem/types.h"

#include "mon_ast.h"
#include "mon_vector.h"
#include "mon_alloc.h"
#include "mon_debug.h"

#define SETJMP_OK  0
#define SETJMP_ERR 1
#define THROW(ctx) longjmp(ctx->jmpBuf, SETJMP_ERR)

/**
 * 	A scope contains symbols. Semantically, a scope constrains the group
 * 	of symbols acessible from a certain portion of the code. Scopes can be
 * 	nested, and thus, enclosed by a greater scope.
 */
typedef struct Scope_ {

	struct Scope_* parentScope;
	Mon_Vector     symbols;

} Scope;

static Scope* s_BuiltinScope = NULL;

/**
 * 	Contains the state of a semantic analysis.
 */
typedef struct {

	/** The scope at the top of the scope stack. */
	Scope* currentScope;

	/** Stores data used by longjmp that allows error handling. */
	jmp_buf jmpBuf;

} Mon_SemAnalysisCtx;

/**
 * 	Pushes a scope onto the scope stack. longjmps if memory fails.
 */
static void PushScope(Mon_SemAnalysisCtx* ctx) {
	MON_CANT_BE_NULL(ctx);
	
	Scope* scope = Mon_Alloc(sizeof(Scope));
	if (scope == NULL) {
		THROW(ctx);
	}
	
	if (Mon_VectorInit(&scope->symbols) != MON_SUCCESS) {
		Mon_Free(scope);
		THROW(ctx);
	}

	scope->parentScope = ctx->currentScope;
	ctx->currentScope = scope;
}

/**
 * 	Destroys a scope, releasing its memory.
 */
static void DestroyScope(Scope* s) {
	MON_VECTOR_FOREACH(&s->symbols, Symbol*, sym, 
		MON_CANT_BE_NULL(sym);
		Mon_Free(sym);
	);
	Mon_VectorFinalize(&s->symbols);
	Mon_Free(s);
}

/**
 * 	Pops the current scope from the stack and sets the current scope
 * 	to the one that was right below it. Releases garbage generated by
 * 	the scope (no need to call DestroyScope() after popping).
 */
static void PopScope(Mon_SemAnalysisCtx* ctx) {
	MON_CANT_BE_NULL(ctx);
	MON_CANT_BE_NULL(ctx->currentScope);

	Scope* parent = ctx->currentScope->parentScope;
	DestroyScope(ctx->currentScope);
	ctx->currentScope = parent;
}

/**
 * 	Releases any garbage contained within the specified context.
 */
static void Cleanup(Mon_SemAnalysisCtx* ctx) {
	MON_CANT_BE_NULL(ctx);

	// Destroy any remaining scopes
	Scope* curr = ctx->currentScope;
	while (curr != NULL) {
		Scope* parent = curr->parentScope;
		DestroyScope(curr);
		curr = curr->parentScope;
	}
}

/**
 * 	Searches for a symbol with the specified name. If none is found,
 * 	NULL is returned.
 */
static Symbol* FindSymbol(const Scope* scope, const char* symName) {
	MON_CANT_BE_NULL(scope);
	MON_CANT_BE_NULL(symName);

	// Search in user space scopes
	while (scope != NULL) {
		MON_VECTOR_FOREACH(&scope->symbols, Symbol*, sym, 
			if (!strcmp(symName, GetSymbolName(sym))) {
				return sym;
			}
		);

		scope = scope->parentScope;
	}

	// Search in builtin scope
	MON_VECTOR_FOREACH(&s_BuiltinScope->symbols, Symbol*, sym,
		if (!strcmp(symName, GetSymbolName(sym))) {
			return sym;
		}
	);

	return NULL;
}

/**
 * 	Searches for a parameter within the scope. If none is found,
 * 	NULL is returned.
 */
static Mon_AstParam* FindParam(const Scope* scope, const char* name) {
	MON_CANT_BE_NULL(scope);
	MON_CANT_BE_NULL(name);

	Symbol* sym = FindSymbol(scope, name);
	if (sym == NULL) {
		return NULL;
	}

	return sym->kind == SYM_PARAM 
		? sym->definition.param 
		: NULL;
}

/**
 * 	Searches for a type within the scope. If none is found,
 * 	NULL is returned.
 */
static Mon_AstTypeDef* FindType(const Scope* scope, const char* name) {
	MON_CANT_BE_NULL(scope);
	MON_CANT_BE_NULL(name);

	Symbol* sym = FindSymbol(scope, name);
	if (sym == NULL) {
		return NULL;
	}
	
	return sym->kind == SYM_TYPE 
		? sym->definition.type 
		: NULL;
}

/**
 * 	Searches for a variable within the scope. If none is found,
 * 	NULL is returned.
 */
static Mon_AstVarDef* FindVar(const Scope* scope, const char* name) {
	MON_CANT_BE_NULL(scope);
	MON_CANT_BE_NULL(name);

	Symbol* sym = FindSymbol(scope, name);
	if (sym == NULL) {
		return NULL;
	}
	
	return sym->kind == SYM_VAR 
		? sym->definition.var 
		: NULL;
}

/**
 * 	Evaluates an expression and returns the type definition node associated
 * 	with its type. Returns NULL if the type cannot be resolved.
 */
static Mon_AstTypeDef* EvaluateExpressionType(const Scope* s, const Mon_AstExp* exp) {
	MON_CANT_BE_NULL(exp);

	if (exp->semantic.type != NULL) {
		return exp->semantic.type;
	}

	switch (exp->expKind) {		
    	case MON_EXP_CONDITIONAL:
			Mon_AstTypeDef* thenType = EvaluateExpressionType(exp->exp.conditionalExpr.thenExpr);
			Mon_AstTypeDef* elseType = EvaluateExpressionType(exp->exp.conditionalExpr.elseExpr);
			if (!IsTypeAssignableFrom(thenType, elseType)) {
				return NULL;
			}
			return thenType;

    	case MON_EXP_UNOP:
			Mon_AstTypeDef* operandType = EvaluateExpressionType(exp->exp.unaryOperation.operand);
			return GetUnopResultType(operandType, exp->exp.unaryOperation.unOpKind);

    	case MON_EXP_BINOP:
			Mon_AstTypeDef* lExpType = EvaluateExpressionType(exp->exp.binaryOperation.left);
			if (lExpType == NULL) {
				return NULL;
			}

			Mon_AstTypeDef* rExpType = EvaluateExpressionType(exp->exp.binaryOperation.right);
			if (rExpType == NULL) {
				return NULL;
			}

			return GetBinopResultType(lExpType, rExpType, exp->exp.binaryOperation.binOpKind);

    	case MON_EXP_CAST:
			Mon_AstTypeDef* destType = FindType(s, exp->exp.castExpr.typeName);
			return 

    	case MON_EXP_VAR:
			break;

    	case MON_EXP_LITERAL:
			break;

    	case MON_EXP_CALL:
			break;

    	case MON_EXP_NEW:
			break;

		default:
			MON_ASSERT(false, "Unimplemented expKind. (got %d).", (int)exp->expKind);
			break;
	}
}

bool PerformSemanticAnalysis(Mon_Ast* ast) {
	MON_CANT_BE_NULL(ast);

	volatile Mon_SemAnalysisCtx ctx;
	ctx.currentScope = NULL;

	if (setjmp(ctx.jmpBuf) != SETJMP_OK) {
		// Errors occurred, cleanup and return accordingly.
		Cleanup(&ctx);
		return false;
	}

	// No errors occurred, proceed with normal execution.
	PushScope(&ctx);

	Cleanup(&ctx);

	return true;
}